[
  {
    "createdAt": 1678330965602,
    "updatedAt": 1678330965602,
    "deletedAt": 0,
    "createdFirstAt": 1678330965602,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/whisperLocalCpp.ts",
    "comment": "Uses https://github.com/ggerganov/whisper.cpp for a more performant implementation of whisper. Still doesn't use GPU, but the inference is much faster than with python on Macbooks.\n\nNB: You need to install ffmpeg and the cpp program, see the github repo for instructions\n\nRelevant cpp cli options:\n\n-tr,      --translate     [false  ] translate from source language to english\n-otxt,    --output-txt    [false  ] output result in a text file\n-ovtt,    --output-vtt    [false  ] output result in a vtt file\n-osrt,    --output-srt    [false  ] output result in a srt file\n-owts,    --output-words  [false  ] output script for generating karaoke video\n-ps,      --print-special [false  ] print special tokens\n-pc,      --print-colors  [false  ] print colors\n-nt,      --no-timestamps [true   ] do not print timestamps\n-l LANG,  --language LANG [en     ] spoken language\n-m FNAME, --model FNAME   [models/ggml-base.en.bin] model path\n-f FNAME, --file FNAME    [       ] input WAV file path\n--prompt PROMPT  [       ] initial prompt",
    "rawStatement": "export const whisperLocalCpp = async (config: WhisperConfig) => {\n  const {\n    isDebug,\n    language,\n    translateToEnglish,\n    model,\n    audioFilePath,\n    prompt,\n    isRetry,\n    isSrtOutputAdded,\n    isVttOutputAdded,\n    isWordSegments,\n  } = config;\n\n  const clonedPath = getRootPath(\"cloned\");\n  if (!clonedPath) {\n    return;\n  }\n  const whisperCppBaseFolderPath = path.join(clonedPath, \"whisper.cpp\");\n  if (!fs.existsSync(whisperCppBaseFolderPath)) {\n    return;\n  }\n\n  const modelFilenameObject: { [modelName in WhisperModelName]: string } = {\n    base: \"models/ggml-base.bin\",\n    \"base.en\": \"models/ggml-base.en.bin\",\n    large: \"models/ggml-large.bin\",\n    \"large-v1\": \"models/ggml-large-v1.bin\",\n    medium: \"models/ggml-medium.bin\",\n    \"medium.en\": \"models/ggml-medium.en.bin\",\n    small: \"models/ggml-small.bin\",\n    \"small.en\": \"models/ggml-small.en.bin\",\n    tiny: \"models/ggml-tiny.bin\",\n    \"tiny.en\": \"models/ggml-tiny.en.bin\",\n  };\n\n  const modelFilename = model ? modelFilenameObject[model] : undefined;\n\n  if (Array.isArray(audioFilePath) && audioFilePath.length === 0) {\n    return;\n  }\n\n  // leave out the ones that are locked\n  const audioFilePaths = makeArray(audioFilePath).filter((p) => !isLocked(p));\n  if (audioFilePaths.length === 0) {\n    console.log(\"all files locked\");\n    return;\n  }\n  const debugString = isDebug ? \"--print-special --print-colors\" : undefined;\n  const languageString = language ? `--language ${language}` : undefined;\n  const translateToEnglishString = translateToEnglish\n    ? `--translate`\n    : undefined;\n  const modelString = modelFilename ? `--model ${modelFilename}` : undefined;\n  const inputFileString = audioFilePaths.map((p) => `\"${p}\"`).join(\" \");\n  const promptString = prompt ? `--prompt ${prompt}` : undefined;\n  const defaultOptionsString = \"--output-txt --output-csv --print-progress\";\n  //--output-words <-- not used: karaoke thing for ffmpeg\n  const wordSegmentsString = isWordSegments ? \"--max-len 1\" : undefined;\n  const srtString = isSrtOutputAdded ? \"--output-srt\" : undefined;\n  const vttString = isVttOutputAdded ? \"--output-vtt\" : undefined;\n\n  const flags = [\n    debugString,\n    srtString,\n    vttString,\n    wordSegmentsString,\n    languageString,\n    promptString,\n    translateToEnglishString,\n    modelString,\n    defaultOptionsString,\n  ].filter(notEmpty);\n\n  const flagsString = flags.length > 0 ? `${flags.join(\" \")}` : \"\";\n\n  const command = `./main ${flagsString} ${inputFileString}`;\n  // console.log({ whisperCommand: command });\n\n  // add a lock for during doing\n\n  await Promise.all(\n    audioFilePaths.map((p) =>\n      lock(p, \"Converting\", \"whisperLocalCpp\", [config])\n    )\n  );\n\n  /**\n   * Doing a custom `exec` for whisper here, because we need fine-grained control on the output. Should run `lock(filePath, percentage)` at least once per minute\n   */\n  const result = await new Promise<{ isSuccessful: boolean; response: string }>(\n    (resolve) => {\n      const execution = spawn(command, {\n        cwd: whisperCppBaseFolderPath,\n        shell: true,\n        // pipe means it goes to stdout.on(\"data\")\n        stdio: \"pipe\",\n      })\n        .on(\"exit\", (code) => {\n          resolve({ response: String(code), isSuccessful: false });\n        })\n        .on(\"message\", (message) => {\n          console.log({ message });\n        })\n        .on(\"error\", (err) => {\n          console.log({ err });\n          resolve({ response: String(err), isSuccessful: false });\n        });\n\n      // stderr is everything logging (including progress)\n      execution.stderr?.on(\"data\", (test: Buffer) => {\n        // console.log(\"data...\", );\n        // const regex = /whisper_full: progress = (\\d+)%/g;\n        // const result = test.toString().match(regex);\n        // const lastResult = result?.pop();\n\n        // if (!lastResult) {\n        //   // not interesting\n        //   return;\n        // }\n\n        // lock the file with the last percentage\n        audioFilePaths.map((audioFilePath) => {\n          lock(audioFilePath, test.toString());\n        });\n\n        // console.log({ lastResult });\n      });\n      // stdout is everything related to the output(not interesting)\n      execution.stdout?.on(\"data\", (data: Buffer) => {\n        if (isDebug) {\n          console.log({ whisper: data.toString() });\n        }\n      });\n    }\n  );\n\n  // remove lock again\n  await Promise.all(audioFilePaths.map((p) => unlock(p)));\n\n  if (result.response !== \"0\") {\n    console.log({ result });\n  }\n  if ([\"5\", \"8\"].includes(result.response) && !isRetry) {\n    // step  1: COMPATABILITY\n\n    // 5 or 8 means the wav isn't 16 bit\n\n    // If the input file is an audio file that is not .wav, convert to wav first\n    // Find all wav's everywhere that aren't 16 bit. Convert to 16 bit if this is the case\n\n    console.log(\"whisper couldn't do it, retrying after conversion\");\n    const result = await Promise.all(\n      audioFilePaths.map((p) => {\n        return compressConvert(p, { is16bitWav: true, targetFormat: \"wav\" });\n      })\n    );\n\n    // console.log(result);\n\n    whisperLocalCpp({ ...config, isRetry: true });\n  }\n\n  // console.log({ result });\n  const paths = audioFilePaths.map((p) => {\n    return {\n      txt: `${p}.txt`,\n      csv: `${p}.csv`,\n      srt: isSrtOutputAdded ? `${p}.srt` : undefined,\n      vtt: isVttOutputAdded ? `${p}.vtt` : undefined,\n    };\n  });\n\n  return paths;\n};",
    "parameters": {},
    "types": [
      "nb"
    ],
    "firstLine": 9,
    "lastLine": 29,
    "id": "azogvtvzsfljtwuslghvhehd"
  }
]