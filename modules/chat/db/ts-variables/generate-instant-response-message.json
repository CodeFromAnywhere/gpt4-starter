{
  "createdAt": 1678611469767,
  "updatedAt": 1678611469767,
  "deletedAt": 0,
  "createdFirstAt": 1678611469767,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "generateInstantResponseMessage",
  "slug": "generate-instant-response-message",
  "operationRelativeTypescriptFilePath": "src/generateInstantResponseMessage.ts",
  "type": {
    "rawType": "(chatMessage: any, person: import(\"/Users/clarity/os/operations/tools/purpose/p2p/peer-types/build/person/Person\").Person, persona: import(\"/Users/clarity/os/operations/tools/purpose/p2p/peer-types/build/Persona\").Persona, config: { isFirstMessage?: boolean | undefined; newUsersAmount?: number | undefined; }) => Promise<ReturnType<(person: import(\"/Users/clarity/os/operations/tools/purpose/p2p/peer-types/build/person/Person\").Person, allMessages: any[], config?: ({ systemMessage?: string | null | undefined; } & import(\"/Users/clarity/os/operations/tools/control-web/openai-wrapper/build/types\").ChatCompletionConfig) | undefined) => Promise<{ isSuccessful: boolean; message?: string | undefined; chatResponse?: string | undefined; isPaywallHit?: boolean | undefined; tokensUsed?: number | undefined; }>>>",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "async (\n  chatMessage: Creation<ChatMessage>,\n  person: Person,\n  persona: Persona,\n  config: { isFirstMessage?: boolean; newUsersAmount?: number }\n): Promise<ReturnType<typeof chat>> => {\n  const words = chatMessage.message.split(\" \");\n  const command = words.length <= 2 ? words[0].toLowerCase() : \"__NO_COMMAND__\";\n\n  const commands = {\n    \"opt-out\": async () => {\n      const result = await db.update(\n        \"Person\",\n        (item) => item.id === person.id,\n        (item) => ({ ...item, isEmailOptOut: true })\n      );\n      return \"You've opted out. You won't receive email communication from us. You can opt-in \";\n    },\n    use: async () => {\n      if (process.env.NODE_ENV === \"production\") {\n        // in prod, just continue...\n        return null;\n      }\n      const slug = words[1]?.toLowerCase();\n      const persona = await getPersona((item) => item.slug === slug);\n      if (!persona) {\n        return \"Couldn't find that bot.\";\n      }\n\n      const result = await db.update(\n        \"Person\",\n        (item) => item.id === person.id,\n        (item) => ({ ...item, customPersonaSlug: slug })\n      );\n\n      return `Success. You're now chatting with ${slug}`;\n    },\n  };\n\n  if (Object.keys(commands).includes(command)) {\n    const thisCommand = commands[command as keyof typeof commands];\n\n    const result = await thisCommand();\n\n    if (result !== null) {\n      return {\n        isSuccessful: true,\n        tokensUsed: 0,\n        isPaywallHit: false,\n        chatResponse: result,\n        message: \"Command result\",\n      };\n    }\n  }\n\n  // get all history, including the new message\n  const history = await getChatMessages(\n    person.slug,\n    persona.slug,\n    Date.now() - 86400000\n  );\n\n  const paywallResult = await getPaywallResult(\n    chatMessage,\n    history,\n    person,\n    persona,\n    config\n  );\n  if (paywallResult.isPaywallHit) {\n    return paywallResult;\n  }\n\n  console.log(`historical messages found: ${history.length}`);\n\n  // const analysis = await getChatMessageAnalysis(chatMessage.message);\n  // console.log({ analysis: analysis.chatResponse });\n  // TODO: this part should be its own function... shares code with `proactiveOutreach`...\n  // generateResponse(history)?\n  const { truncatedMessages, inputTokensCalculated } =\n    truncateMessages(history);\n\n  const assistantState = persona.assistantState;\n\n  const systemMessage = getSystemMessage(person, persona);\n\n  const allMessages: Creation<ChatMessage>[] = (\n    truncatedMessages as Creation<ChatMessage>[]\n  ).concat(chatMessage);\n\n  console.log({ systemMessage });\n\n  const chatResult = await chat(person, allMessages, {\n    isInstant: true,\n    inputTokensCalculated,\n    systemMessage,\n  });\n\n  if (config.isFirstMessage) {\n    // TODO: translate\n    const initialTermsMessage = `Hi there, this is ${persona.name} speaking!\n\nYou can send me ${\n      getMessageLimitInfo(person, persona).freeMessagesAmount\n    } free messages. After that, you'll be prompted to buy new messages for ${\n      getCostPerMessageCredit(persona) * 100\n    } cents per message.\n\nIf you continue to talk with me, you are agreeing with our privacy policy and terms of use, which can be found here:\n\nhttps://codefromanywhere.com/privacy-policy\n`;\n    chatResult.chatResponse = chatResult.chatResponse\n      ? `\n${initialTermsMessage}\n---\nTo answer your first message:\n\n${chatResult.chatResponse}`\n      : initialTermsMessage;\n  }\n\n  if (!chatResult.isSuccessful) {\n    console.log({ chatResult });\n  }\n  return chatResult;\n}",
  "description": "Based on a new incoming message and the found model instances, an instant response can be sent back.\n\nIf not, just return undefined.",
  "id": "plhuksdietdbxfazjrznzncy"
}