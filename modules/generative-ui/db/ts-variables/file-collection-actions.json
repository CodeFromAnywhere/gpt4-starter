{
  "createdAt": 1678041377011,
  "updatedAt": 1678041377011,
  "deletedAt": 0,
  "createdFirstAt": 1678041377011,
  "classification": "const",
  "comments": [],
  "isExported": true,
  "name": "FileCollectionActions",
  "slug": "file-collection-actions",
  "operationRelativeTypescriptFilePath": "src/FileCollectionActions.tsx",
  "type": {
    "rawType": "() => JSX.Element",
    "typeDefinition": {
      "type": "object",
      "properties": {},
      "optional": false
    },
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": true,
    "isPrimitive": false,
    "isEnumLiteral": false,
    "simplifiedSchema": {
      "properties": [],
      "type": "object"
    }
  },
  "value": "() => {\n  const queryPath = useQueryPath();\n  const [isUploading, setIsUploading] = useState(false);\n  const alert = useAlert();\n\n  const navigationQuery = queries.useGetNavigationWithContext({ queryPath });\n  const openFilesQuery = queries.useGetOpenFilesWithContext();\n  const openFiles = openFilesQuery.data?.result;\n\n  const fileCollectionQuery =\n    queries.useGetFileCollectionWithContext(queryPath);\n\n  const { projectRelativeFilePath, projectRelativeFolderPath, markdownIndex } =\n    destructureOptionalObject(fileCollectionQuery?.data?.result);\n\n  const isPinned = openFiles?.find(\n    (x) => x.projectRelativePath === projectRelativeFilePath\n  );\n\n  const authorizationQuery =\n    queries.useGetFsAuthorizationWithContext(queryPath);\n\n  const meQuery = queries.useGetMeWithContext();\n\n  const isAdmin =\n    !!meQuery.data?.result?.device?.currentPersonCalculated?.groupSlugs?.includes(\n      \"admin\"\n    );\n\n  const { canRead, canWrite } = destructureOptionalObject(\n    authorizationQuery.data?.result\n  );\n\n  const downloadAction: ContextMenuItem = {\n    id: \"export\",\n    getTitle: () => \"â¬‡ï¸ Export\",\n    getIsEnabled: () => true,\n    onClick: () => {\n      alert?.(\n        \"Export\",\n        \"Download the file-collection or download the entire folder?\",\n        [\n          {\n            text: \"File collection\",\n            onPress: async () => {\n              if (!projectRelativeFilePath) return;\n              await openDownload(projectRelativeFilePath);\n            },\n            style: \"default\",\n          },\n          {\n            text: \"Folder\",\n            onPress: async () => {\n              if (!projectRelativeFolderPath) return;\n              await openDownload(projectRelativeFolderPath);\n            },\n            style: \"destructive\",\n          },\n          { text: \"Cancel\", style: \"cancel\" },\n        ]\n      );\n    },\n  };\n\n  const openAction: ContextMenuItem = {\n    id: \"open\",\n    getTitle: () => \"â†©ï¸ Open with\",\n    getIsEnabled: () => isAdmin,\n    onClick: () => {\n      alert?.(\"Open with\", \"Which application do you want to open?\", [\n        {\n          text: \"File Explorer\",\n          onPress: () => {\n            const projectRelativePath =\n              projectRelativeFilePath || projectRelativeFolderPath;\n\n            if (!projectRelativePath) {\n              return;\n            }\n\n            api.openFinder(projectRelativePath);\n          },\n          style: \"default\",\n        },\n        {\n          text: \"Terminal\",\n          onPress: () => {\n            if (!projectRelativeFolderPath) return;\n\n            alert?.(\n              \"Coming soon... should open a terminal in some folder. quite useful though bit hard to make cross platform.\"\n            );\n          },\n          style: \"default\",\n        },\n        { text: \"Cancel\", style: \"cancel\" },\n      ]);\n    },\n  };\n\n  const pinAction: ContextMenuItem = {\n    id: \"pin\",\n    getTitle: () => \"ðŸ“Œ Pin\",\n    getIsEnabled: () => true,\n    onClick: async () => {\n      const action = isPinned ? \"unpin\" : \"pin\";\n      const result = await api.setOpenFileWithContext(queryPath, action);\n      openFilesQuery.refetch();\n\n      alert?.(isPinned ? \"Removed pin\" : \"Pinned\");\n    },\n  };\n\n  const authorizationAction: ContextMenuItem = {\n    id: \"permission\",\n    getTitle: () => \"ðŸ” Permissions\",\n    getIsEnabled: () => !!canWrite,\n    onClick: () => {\n      alert?.(\n        \"Change Permissions\",\n        \"Choose which permission you want to change\",\n        [\n          {\n            onPress: () => {\n              updateFrontmatter(\n                projectRelativeFilePath,\n                {\n                  isPrivate: markdownIndex?.isPrivate ? \"false\" : \"true\",\n                },\n                fileCollectionQuery.refetch\n              );\n            },\n            text: markdownIndex?.isPrivate\n              ? \"ðŸ”‘ Unset private\"\n              : \"ðŸ”‘ Set private\",\n          },\n\n          {\n            onPress: () => {\n              updateFrontmatter(\n                projectRelativeFilePath,\n                {\n                  isAnonymous: markdownIndex?.isAnonymous ? \"false\" : \"true\",\n                },\n                fileCollectionQuery.refetch\n              );\n            },\n            text: markdownIndex?.isAnonymous\n              ? \"ðŸ•µï¸â€â™‚ï¸ Make nominous\"\n              : \"ðŸ•µï¸â€â™‚ï¸ Make anonimous\",\n          },\n\n          {\n            onPress: () => {\n              updateFrontmatter(\n                projectRelativeFilePath,\n                {\n                  isDraft: markdownIndex?.isDraft ? \"false\" : \"true\",\n                },\n                fileCollectionQuery.refetch\n              );\n            },\n            text: markdownIndex?.isDraft ? \"ðŸ§ª Undraft\" : \"ðŸ§ª Draft\",\n          },\n\n          {\n            onPress: () => {\n              updateFrontmatter(\n                projectRelativeFilePath,\n                {\n                  isPublic: markdownIndex?.isPublic ? \"false\" : \"true\",\n                },\n                fileCollectionQuery.refetch\n              );\n            },\n            text: markdownIndex?.isPublic ? \"ðŸ‘€ Set unpublic\" : \"ðŸ‘€ Set public\",\n          },\n\n          {\n            onPress: () => {\n              updateFrontmatter(\n                projectRelativeFilePath,\n                {\n                  isSecret: markdownIndex?.isSecret ? \"false\" : \"true\",\n                },\n                fileCollectionQuery.refetch\n              );\n            },\n            text: markdownIndex?.isSecret ? \"ðŸ‘€ Set open\" : \"ðŸ‘€ Set secret\",\n          },\n        ]\n      );\n      //  navigationQuery.refetch()\n    },\n  };\n\n  const renameAction: ContextMenuItem = {\n    id: \"rename\",\n    getTitle: () => \"âœï¸ Rename\",\n    getIsEnabled: () => !!canWrite,\n    onClick: async () => {\n      if (!projectRelativeFilePath) return;\n      let newFilename = prompt(\n        \"What should the new name be?\",\n        getFileOrFolderName(projectRelativeFilePath)\n      );\n      if (!newFilename) return;\n\n      const apiResult = await api.renameFileOrFolderWithContext(\n        projectRelativeFilePath,\n        newFilename\n      );\n\n      showStandardResponse(apiResult);\n      if (apiResult?.result?.isSuccessful) {\n        // refetch nav, navigate to new name with router.push\n      }\n    },\n  };\n\n  const moveAction: ContextMenuItem = {\n    id: \"move\",\n\n    getTitle: () => \"â¤µï¸ Move\",\n    getIsEnabled: () => true,\n    onClick: async () => {\n      if (!projectRelativeFilePath) return;\n\n      let newLocation = prompt(\n        \"Where should this file/folder be moved to?\",\n        projectRelativeFilePath\n      );\n\n      if (!newLocation) return;\n\n      const apiResult = await api.movePathWithContext(\n        projectRelativeFilePath,\n        newLocation\n      );\n\n      showStandardResponse(apiResult);\n      if (apiResult?.result?.isSuccessful) {\n        //router push and reload nav\n      }\n    },\n  };\n\n  const copyAction: ContextMenuItem = {\n    getTitle: () => \"ðŸ‘¯ Copy\",\n    getIsEnabled: () => !!canWrite,\n    id: \"copy\",\n    onClick: async () => {\n      if (!projectRelativeFilePath) return;\n\n      const apiResult = await api.copyPathWithContext(projectRelativeFilePath);\n\n      showStandardResponse(apiResult);\n\n      if (apiResult?.result?.isSuccessful) {\n        navigationQuery.refetch();\n      }\n    },\n  };\n\n  const automationsAction: ContextMenuItem = {\n    id: \"run\",\n\n    getTitle: () => \"âš¡ï¸ Run\",\n    getIsEnabled: () => true,\n    onClick: () => {\n      /**\n      TODO:\n      - make file-function `runAllWatchers` which searches all applicable watchers and runs them for a file, file collection, or folder (recursively)\n      - make `runEvery(fn, path, \"folder\"|\"collection\"|\"file\")` which executes a file function for all files in a folder, file collection, or single file\n      - make function `getFileFunctions(path)` which returns an array of functions available for this file or folder path\n\n      FRONTEND\n\n      1. query which functions are available for this file-collection/folder\n      2. run the file function\n      3. also make this available for a folder\n      */\n      alert?.(\"select filefunction to run\");\n    },\n  };\n\n  const addFileAction: ContextMenuItem = {\n    id: \"new\",\n    getTitle: () => \"âž• New\",\n    getIsEnabled: () => !!canWrite,\n    onClick: () => {\n      alert?.(\"New\", \"What do you want to do?\", [\n        {\n          text: \"New text\",\n          onPress: () => {\n            alert?.(\"new text in file-collection\");\n          },\n        },\n\n        {\n          text: \"New file\",\n          onPress: async () => {\n            let filename = prompt(\n              \"What should be the name (including extension)?\",\n              \"untitled.md\"\n            );\n            if (!filename || filename === \"\") return;\n\n            const projectRelativePath = `${projectRelativeFolderPath}/${filename}`;\n\n            const apiResult = await api.newFileWithContext(projectRelativePath);\n\n            showStandardResponse(apiResult);\n\n            if (apiResult?.result?.isSuccessful) {\n              navigationQuery.refetch();\n            }\n          },\n        },\n\n        {\n          text: \"New folder\",\n          onPress: async () => {\n            let folderName = prompt(\"What should be the name?\", \"\");\n            if (!folderName || folderName === \"\") return;\n            if (!projectRelativeFolderPath) return;\n\n            const apiResult = await api.newFolderWithContext(\n              projectRelativeFolderPath,\n              folderName\n            );\n\n            showStandardResponse(apiResult);\n\n            if (apiResult?.result?.isSuccessful) {\n              navigationQuery.refetch();\n            }\n          },\n        },\n\n        {\n          text: \"Download from Youtube\",\n          onPress: async () => {\n            if (!projectRelativeFolderPath) return;\n\n            let youtubeUrl = prompt(\"Please provide the youtube url\", \"\");\n\n            if (!youtubeUrl) return;\n\n            const result = await api.youtubeToMp4WithContext(\n              youtubeUrl,\n              projectRelativeFolderPath\n            );\n\n            setTimeout(() => {\n              navigationQuery.refetch();\n            }, 100);\n\n            showStandardResponse(result);\n          },\n        },\n\n        // {\n        //   text: \"Upload files\",\n        //   onPress: async () => {\n        //     document.getElementById(\"fileupload\")?.focus();\n        //     document.getElementById(\"fileupload\")?.click();\n        //     // select files (directly opens upload-file modal, this should be a hook or mini component)\n        //   },\n        // },\n\n        {\n          text: \"Cancel\",\n          style: \"cancel\",\n        },\n      ]);\n    },\n  };\n\n  const deleteAction: ContextMenuItem = {\n    id: \"delete\",\n    getTitle: () => \"Delete\",\n    getIsEnabled: () => !!canWrite,\n    onClick: () => {\n      alert?.(\"Are you sure?\", `Do you want to delete this file collection?`, [\n        { style: \"cancel\", text: \"Cancel\" },\n        {\n          text: \"Delete\",\n          style: \"destructive\",\n          onPress: async () => {\n            if (!projectRelativeFilePath) return;\n\n            // delete also works, but trash seems better for now.\n            const apiResult = await api.deleteFileOrFolderWithContext(\n              projectRelativeFilePath\n            );\n\n            showStandardResponse(apiResult);\n\n            if (apiResult?.result?.isSuccessful) {\n              navigationQuery.refetch();\n              fileCollectionQuery.refetch();\n              // TODO: should navigate elsewhere, this doesn't exist anymore...\n            }\n          },\n        },\n      ]);\n    },\n  };\n\n  const allActions = [\n    downloadAction,\n    openAction,\n    authorizationAction,\n    pinAction,\n    renameAction,\n    moveAction,\n    automationsAction,\n    addFileAction,\n    copyAction,\n    deleteAction,\n  ];\n\n  return (\n    <Div>\n      <Div className=\"flex flex-row flex-wrap\">\n        {allActions.map((action, index) => (\n          <ContextMenuItemComponent\n            key={`filecollectionaction${action.id}-${index}}`}\n            action={action}\n            projectRelativeFilePath={queryPath}\n          />\n        ))}\n      </Div>\n\n      <Div className=\"mx-2\">\n        <AssetInput\n          immediateUpload\n          defaultAssetName=\"upload\"\n          onChangeLoading={(isLoading) => {\n            if (!isLoading) return;\n            setIsUploading(true);\n          }}\n          onChange={async (value) => {\n            if (!value || value.length === 0) {\n              return;\n            }\n            setIsUploading(true);\n\n            const apiResult = await api.processAssetUploadWithContext(\n              projectRelativeFolderPath,\n              value\n            );\n\n            if (!apiResult.result?.isSuccessful) {\n              alert?.(\"Error uploading\", apiResult.result?.message);\n            }\n\n            setIsUploading(false);\n\n            navigationQuery.refetch();\n          }}\n          projectRelativeReferencingFilePath={projectRelativeFilePath || \"\"}\n          allowMultiple\n          inputTypes={[\"files\"]}\n        />\n        {isUploading ? <FancyLoader /> : null}\n      </Div>\n    </Div>\n  );\n}",
  "description": "All actions should refetch the required stuff\n\nPermissions button\n\nRename/move button for file-collections\n\nDelete entire file-collection",
  "id": "rdpuwljhurfmwzbzmyxgfruy"
}