[
  {
    "createdAt": 1677579962374,
    "updatedAt": 1677579962374,
    "deletedAt": 0,
    "createdFirstAt": 1677579962374,
    "name": "Comment",
    "slug": "comment",
    "operationRelativeTypescriptFilePath": "src/detectLanguage.ts",
    "comment": "Function that can efficiently detect the language of any content\n\nperformance: takes ±15ms now, seems okay, if needed there are plenty ways to improve it!\n\n# IDEAS:\n\n✅ use `/Users/clarity/os/operations/tools/language/simplify-text/assets/unigram-frequencies-object.json` to make `detectLanguage` for english (remove the uncommon words to make it more efficient, also, we can simply use a string with spaces and apply \"includes\", maybe that's faster, or an array? if we just use the top 2000 words or so, it's plenty fast though, probably)\n\nmake `detectLanguage(string/filePath, canContainMultiple?:boolean) => {[Language]:number}` that either efficiently matches only the first words if there can only be one language, or the whole text if there can be more. if percentage of words that are english is too low, it's \"other\" for now (which is probably dutch, then xD)\n\n\n# OLD NOTES:\n\ndata prereq\n\n1) get 10000 most common words of all major languages\n2) create multiple sub-dataset of that with X most common words for every language\n\nfunction:\n3) parse input into markdown paragraphs and go over every part based on variability\n4) for every piece of content, for every word, find it in every common-words-array... if the % of words for one language is higher than 80% at some point that is more than 5 words, we are pretty sure that it's that language\n5) return a MarkdownParse where the language is specified at every level (or, for a simple string, simply return the detected language)\n\nafterthoughts:\n\n- optionally we can use the context for having a more accurate and logial detection in case the amount of words in a piece of content is insufficient. it is not simply nearest neighbor, but more of a downwards up: the heading always follows the content... But for JSON it IS the nearest neighbor\n\n\nOther data I want: a language matrix! simply put the 10000 most common words of English in google translate one-by-one (maybe it works with newlines?) (or, if we have it by then, use the offline translation)\n\nThat can become a language matrix. of course there will be mistakes, but it will already be super useful",
    "rawStatement": "export const detectLanguage = (\n  text: string,\n  canContainMultipleLanguages?: boolean\n) => {\n  /*\nOLD:\n\n{}: {\n  text?: string;\n  markdown?: string;\n  json?: any;\n  variability?: \"sentence\" | \"paragraph\" | \"subheader\" | \"header\" | \"none\";\n  accuracy?: \"low\" | \"medium\" | \"high\";\n}*/\n\n  // for performance reasons, take the first 10k characters\n  const substring = text.substring(0, 10000);\n\n  //TODO: improve this by simply replacing any non-alphabetical character with a space, should be fine\n  const punctuation = \"()!@#$%^&*,./'\\\"`-_\\n\\\\:[]?\\r’\";\n  const withoutPunctuation = punctuation\n    .split(\"\")\n    .reduce(\n      (previous, character) => previous.replaceAll(character, \" \"),\n      substring\n    );\n\n  const words = withoutPunctuation\n    .split(\" \")\n    .filter((word) => word.length >= 1);\n\n  //console.log({ wordsLen: words.length });\n\n  const isCommonWordBooleanArray = words.map((word) =>\n    topEnglishWords.includes(word.toLowerCase())\n  );\n\n  const commonEnglishWordRatio =\n    isCommonWordBooleanArray.filter((x) => !!x).length / words.length;\n\n  // console.log({ commonEnglishWordRatio });\n\n  if (commonEnglishWordRatio > 0.5) return \"english\";\n\n  return \"other\";\n};",
    "parameters": {},
    "types": [],
    "firstLine": 3,
    "lastLine": 36,
    "id": "mibjtjjmqbweodbeahgxhsfz"
  }
]