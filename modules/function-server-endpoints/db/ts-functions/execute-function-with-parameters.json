{
  "createdAt": 1678329821310,
  "updatedAt": 1678329821310,
  "deletedAt": 0,
  "createdFirstAt": 1678329821310,
  "isApiExposed": false,
  "isExported": true,
  "operationRelativeTypescriptFilePath": "src/executeFunctionWithParameters.ts",
  "commentsInside": [],
  "rawText": " async <\n  TFunctionName extends keyof typeof sdk\n>(\n  functionName: TFunctionName,\n  parameters: undefined | any[],\n  serverContext: Context\n): Promise<RealApiReturnType<any>> => {\n  const publicBundleConfig = await getPublicBundleConfig();\n  const executionId = generateId();\n\n  if (isRawEndpoint(functionName)) {\n    const result = await (sdk[functionName] as any)(serverContext);\n    return result;\n  }\n\n  if (isGetEndpoint(functionName)) {\n    // NB: shortcut for now, until we have cookie support:\n\n    const result = await (sdk[functionName] as any)(serverContext);\n\n    return result;\n  }\n\n  const performance: (PerformanceItem | undefined)[] = [];\n\n  performance.push(getNewPerformance(\"start\", executionId, true));\n\n  // 1) upsert device\n  const device = await upsertDevice(serverContext);\n  if (!device) {\n    console.log(\"Couldn't create device\");\n    return {\n      isSuccessful: false,\n      message: \"Couldn't create device\",\n    };\n  }\n\n  performance.push(getNewPerformance(\"upsertDevice\", executionId));\n\n  // 2) get ts function\n  const tsFunction = await getTsFunction(functionName);\n  if (!tsFunction) {\n    return {\n      isSuccessful: false,\n      message: `TsFunction file could not be found in \"sdk-function-paths\" (${functionName}). Maybe you need to rebuild your operation and update your SDK?`,\n    };\n  }\n  performance.push(getNewPerformance(\"getTsFunction\", executionId));\n\n  // 4) cache lookup\n  const cacheLookupResult = cacheLookup(functionName, parameters);\n  if (cacheLookupResult.hasValidCache) {\n    return {\n      result: cacheLookupResult.result,\n      isSuccessful: true,\n      isCached: true,\n    };\n  }\n  performance.push(getNewPerformance(\"cacheLookup\", executionId));\n\n  // 5) validation\n\n  //@ts-ignore\n  const validationResult = validateInput(functionName, parameters, tsFunction);\n\n  // if (!validationResult.isValid) {\n  //   return {\n  //     isSuccessful: false,\n  //     errors: validationResult.errors,\n  //     message: `Your input has some errors. Input ${JSON.stringify(\n  //       parameters\n  //     )}.`,\n  //   };\n  // }\n  performance.push(getNewPerformance(\"inputValidation\", executionId));\n\n  // 5) Every conversion in your folder should reduce credits. Start with the whisper watcher and gpt watcher.\n  // wrap the function with some payment to deduce credit based on the return statement, which should also add it to a logging for where the credits go to\n\n  const fn = sdk[functionName];\n\n  if (typeof fn !== \"function\") {\n    return {\n      isSuccessful: false,\n      message: `Function not found in the api-sdk: ${functionName}`,\n    };\n  }\n  // before execution: check if the function config says \"isPaid\". If so, first `checkBalance`\n\n  const config: StandardFunctionConfig | undefined = fn.config;\n  if (config?.isPaid) {\n    const cost = config?.priceCredit;\n    const myCredit = device?.currentPersonCalculated?.credit;\n\n    if (cost && (!myCredit || myCredit < cost)) {\n      return {\n        isSuccessful: false,\n        isBalanceInsufficient: true,\n        message: `You don't have enough credits. It's estimated this action will cost ${myCredit} credits. Please deposit some money and buy more credits first.`,\n      };\n    }\n  }\n\n  // 6) running function\n\n  const hasAuthorization = getAuthorizationInfo(device, fn);\n\n  if (publicBundleConfig?.slug !== \"passionfruit\" && !hasAuthorization) {\n    return {\n      isSuccessful: false,\n      isUnauthorized: true,\n      message:\n        \"You are not authorized to execute this function, you might need to login.\",\n    };\n  }\n\n  // 3) passionfruit auth\n  // OLD simple way (passionfruit-only, to be deprecated once admin signup works good enough)\n  const authToken: string | undefined = serverContext.data?.authToken;\n  if (\n    publicBundleConfig?.slug === \"passionfruit\" &&\n    privateAuthToken !== authToken\n  ) {\n    return {\n      isSuccessful: false,\n      isUnauthorized: true,\n      message: \"You are not authorized to execute this function.\",\n    };\n  }\n\n  performance.push(getNewPerformance(\"auth\", executionId));\n\n  /**\n   * Convention\n   */\n\n  const needsReturnRaw =\n    functionName.endsWith(apiConventions.rawFunctionConventionSuffix) ||\n    functionName.endsWith(apiConventions.getFunctionConventionSuffix);\n\n  const needsFunctionContext =\n    functionName.endsWith(apiConventions.contextFunctionConventionSuffix) ||\n    needsReturnRaw;\n\n  const functionContext: FunctionContext = {\n    device,\n    groups: device.currentPersonCalculated?.groups,\n    authToken: device.authToken,\n    tsFunction,\n    hasAuthorization,\n    serverContext,\n  };\n\n  const parametersWithContext = needsFunctionContext\n    ? [functionContext].concat(parameters || [])\n    : parameters;\n\n  // extra step: validate the filepath for `FileFunction` functions\n\n  // console.log(`We are authorized to execute ${functionName}! Let's do it`);\n  // @ts-ignore\n  const result = await fn(...parametersWithContext);\n  performance.push(getNewPerformance(\"function\", executionId));\n\n  cleanupTimer(executionId);\n\n  //@ts-ignore\n  const resultValidation = validateResult(functionName, result, tsFunction);\n\n  // console.log({ serverwithPar: performance });\n\n  let cost: number | undefined = undefined;\n  let personId: string | undefined = undefined;\n  let groupId: string | undefined = undefined;\n  // After execution,before returning anything, check the response in case of `.isPaid:true`. Alter credit and add log\n  if (config?.isPaid) {\n    const { payment }: StandardResponse = result;\n\n    cost =\n      payment?.priceCredit !== undefined\n        ? payment.priceCredit\n        : config?.priceCredit;\n\n    if (cost !== undefined) {\n      // cost is known\n      if (payment?.personId) {\n        await db.update(\n          \"Person\",\n          (item) => item.id === payment.personId,\n          (item) => ({\n            ...item,\n            credit: cost ? (item.credit || 0) - cost : item.credit,\n          })\n        );\n\n        // NB: maybe should decouple more due to high number of rows in this table, but might be fine depending on how we are using this.\n        await db.upsert(\"FunctionExecution\", {\n          functionName: fn.name,\n          inputParameters: [],\n          isExample: false,\n          isResultFromCache: false,\n          isTest: false,\n          output: result,\n          performance: [],\n          tsFunctionId: tsFunction.id,\n          cost,\n          personId: payment.personId,\n        });\n      } else {\n        console.log(\n          `NB: group payments not implemented yet, payment has cost but no personId given...`\n        );\n      }\n    }\n  }\n\n  // 6) store performance\n  storeFunctionExecution(\n    tsFunction,\n    parameters,\n    result,\n    performance.filter(notEmpty),\n    false,\n    { cost, personId, groupId }\n  );\n\n  // need to return this immediately without the surrounding object, because it might do stuff with that server context that needs to be returned\n  if (needsReturnRaw) return result;\n\n  if (result === undefined) {\n    return {\n      isSuccessful: true,\n      isCached: false,\n      message: \"Function was executed but did not give any response\",\n      result: undefined,\n    };\n  }\n\n  return {\n    isSuccessful: true,\n    isCached: false,\n    result,\n  };\n}",
  "name": "executeFunctionWithParameters",
  "slug": "execute-function-with-parameters",
  "parameters": [],
  "description": "steps for someone to use the API\n\n1) auth\n2) cache lookup\n3) input validation\n4) running function\n5) store cache\n6) store performance\n7) returning result\n\nTODO: make it possible to return result BEFORE storing cache and performance. we probably need to use the server.reply for this, which makes this function unusable in any other setting than an api, so let's make it optional",
  "returnType": {
    "rawType": "Promise<import(\"/Users/clarity/os/operations/tools/user-interfaces/api/api-types/build/api-types\").ApiReturnType<any>>",
    "typeCoverage": 0,
    "isArray": false,
    "isEnum": false,
    "isObject": false,
    "isPrimitive": false,
    "isEnumLiteral": false
  },
  "maxIndentationDepth": 6,
  "size": {
    "characters": 7586,
    "lines": 254,
    "bytes": 7586,
    "bytesPerCharacter": 1,
    "charactersPerLine": 30,
    "linesPerFile": 254,
    "numberOfFiles": 1
  },
  "id": "scghhhgucihwaengtvxvybon"
}